/ *
** Biblioteca de suporte de validação discreta para jQuery e jQuery Validar
** Copyright (C) Microsoft Corporation. Todos os direitos reservados.
* /
! function (a) {function e (a, e, n) {a.rules [e] = n, a.message && (a.messages [e] = a.message)} função n (a) {return a. substituir (/ ^ \ s + | \ s + $ / g, ""). split (/ \ s *, \ s * / g)} função t (a) {return a.replace (/ ([! "# $% & '() * +,. / :; <=>? @ \ [\\\] ^ `{|} ~]) / g," \\ $ 1 ")} função r (a) {return a.substr (0, a.lastIndexOf (".") + 1)} função i (a, e) {return 0 === a.indexOf ("*.") && (a = a.replace ("*.", e)), a} função o (e, n) {var r = a (this) .find ("[data-valmsg-for = '" + t (n [0] .name) + "']") , i = r.attr ("data-valmsg-replace"), o = i? a.parseJSON (i)! ==! 1: null; r.removeClass ("validação de campo válido"). addClass (" campo-validação-erro "), e.data (" unobtrusiveContainer ", r), o? (r.empty (), e.removeClass (" input-validation-error "). appendTo (r)): e.hide ()} função d (e,n) {var t = a (this) .find ("[data-valmsg-summary = true]"), r = t.find ("ul"); r && r.length && n.errorList.length && (r.empty () , t.addClass ("validation-summary-errors"). removeClass ("validation-summary-válido"), a.each (n.errorList, function () {a ("<li />").html(this .message) .appendTo (r)}))} função s (e) {var n = e.data ("unobtrusiveContainer"); se (n) {var t = n.attr ("data-valmsg-replace") , r = t? a.parseJSON (t): null; n.addClass ("validação de campo válido"). removeClass ("field-validation-error"), e.removeData ("unobtrusiveContainer"), r && n.empty ()}}}} {n.data (t,! 0); tente {n.data (t), {n.data (t), {n.data (t) ("validador"). resetForm ()} finalmente {n.removeData (t)} n.find (".validação-resumo-erros "). addClass (" validação-resumo-válido "). removeClass (" validation-summary-errors "), n.find (". field-validation-error "). addClass (" validação de campo " -valid "). removeClass (" field-validation-error "). removeData (" unobtrusiveContainer "). find ("> * "). removeData (" unobtrusiveContainer ")}} função m (e) {var n = a ( e), t = n.data (v), r = a.proxy (l, e), i = p.unobtrusive.options || {}, m = função (n, t) {var r = i [n ]; r && a.isFunction (r) && r.apply (e, t)}; return t || (t = {options: {errorClass: i.errorClass || "input-validation-error", errorElement: i.errorElement | | "span", errorPlacement: function () {o.apply (e, arguments), m ("errorPlacement", argumentos)}, invalidHandler: function () {d.apply (e, arguments), m ("invalidHandler" , argumentos)}, mensagens: {},regras: {}, sucesso: function () {s.apply (e, arguments), m ("sucesso", argumentos)}}, attachValidation: function () {nhoff ("reset") + v, r) .on ("reset." + v, r) .validate (this.options)}, validate: function () {return n.validate (), n.valid ()}}, n.data (v, t) ), t} var u, p = a.validator, v = "unlobtrusiveValidation"; p.unobtrusive = {adaptadores: [], parseElement: function (e, n) {var t, r, i, o = a (e ), d = o.parents ("form") [0]; d && (t = m (d), t.options.rules [e.name] = r = {}, t.options.messages [e.name ] = i = {}, a.each (this.adapters, function () {var n = "data-val -" + this.name, t = o.attr (n), s = {}; void 0! == t && (n + = "-", a.each (this.params, function () {s [this] = o.attr (n + this)}), this.adapt ({element: e, form: d , mensagem: t, params: s, regras: r, mensagens: i}))}), a.extend (r, {__ dummy __ :! 0)), n || t.attachValidation ())}, parse: function (e) {var n = a (e), t = n.parents (). addBack ().filtro ("formulário"). add (n.find ("form")). tem ("[data-val = true]"); n.find ("[data-val = true]"). cada (função () {p.unobtrusive.parseElement (this,! 0)}), t.each (function () {var a = m (this); a && a.attachValidation ()})}}, u = p.unobtrusive.adapters u.add = function (a, e, n) {return n || (n = e, e = []), this.push ({name: a, params: e, adapte: n}), isto} u.addBool = function (a, n) {return this.add (a, function (t) {e (t, n || a,! 0)})}, u.addMinMax = função (a, n, t, r, i, o) {return this.add (a, [i || "min", o || "max"], função (a) {var i = a.params.min, o = a. Params.max; i && o? e (a, r, [i, o]): i? e (a, n, i): o && e (a, t, o)})}, u.addSingleVal = função (a, n, t) {retorna this.add (a, [n || "val"], função (r) {e (r, t || a, r.params [n])})}, p.addMethod ( "__dummy __", função (a, e, n) {return! 0}), p.addMethod ("regex", função (a, e, n) {var t; retorna isso.opcional (e) ?! 0: (t = novo RegExp (n) .exec (a), t && 0 === t.index && t [0] .length === a.length)}), p.addMethod ("nonalphamine ", função (a, e, n) {var t; return n && (t = a.match (/ \ W / g), t = t && t.length> = n), t}), p.methods.extension? (u.addSingleVal ("extensão", "extensão")): u.addSingleVal ("extensão", "extensão", "aceitar"), u.addSingleVal ("extensão", "extensão"): u.addSingleVal ("extensão" Regex "," padrão "), u.addBool (" cartão de crédito "). addBool (" data "). addBool (" dígitos "). addBool (" email "). addBool (" número "). addBool (" url " ), u.addMinMax ("length", "minlength", "maxlength", "rangelength"). addMinMax ("range", "min", "max", "range"), u.addMinMax ("minlength "," minlength "). addMinMax (" maxlength "," minlength "," maxlength "), u.add (" equalto ", [" other "], função (n) {var o = r (n. .name), d = n.params.other, s = i (d, o), l = a (n.form) .find (": input"). filtro ("[name = '" + t (s) ) + "']") [0]; e (n, "equalTo", l)}), u.add ("required", function (a) {("INPUT"! == a.element.tagName. toUpperCase () || "CHECKBOX"! == a.element.type.toUpperCase ()) && e (a, "required",! 0)}), u.add ("remoto", ["url", "tipo" "," additionalalfields "], function (o) {var d = {url: o.params.url, digite: o.params.type ||" GET ", dados: {}}, s = r (o.element .name); a.each (n (o.params.additionalfields || o.element.name), função (e, n) {var r = i (n, s); d.data [r] = função ( ) {var e = a (o.form) .find (":input "). filter (" [name = '"+ t (r) +"'] "); return e.is (": checkbox ")? e.filter (": checked "). val () || e.filter (": oculto"). val () || "": e.is (": radio")? e.filter (": checked"). val () || "": e.val ( )}}), e (o, "remote", d)}), u.add ("senha", ["min", "nonalphamin", "regex"], função (a) {a.params.min && e (a, "minlength", a.params.min), a.params.nonalphamin && e (a, "nonalphamin", a.params.nonalphamin), a.params.regex && e (a, "regex", a.params.regex )}), a (function () {p.unobtrusive.parse (document)})} (jQuery);é (": rádio")? e.filter (": verificado"). val () || "": e.val ()}}), e (o, "remoto", d)}), u. adicionar ("senha", ["min", "nonalphamin", "regex"], função (a) {a.params.min && e (a, "minlength", a.params.min), a.params.nonalphamin && e ( a, "nonalphamin", a.params.nonalphamin), a.params.regex && e (a, "regex", a.params.regex)}), a (function () {p.unobtrusive.parse (document)}) } (jQuery);é (": rádio")? e.filter (": verificado"). val () || "": e.val ()}}), e (o, "remoto", d)}), u. adicionar ("senha", ["min", "nonalphamin", "regex"], função (a) {a.params.min && e (a, "minlength", a.params.min), a.params.nonalphamin && e ( a, "nonalphamin", a.params.nonalphamin), a.params.regex && e (a, "regex", a.params.regex)}), a (function () {p.unobtrusive.parse (document)}) } (jQuery);regex ", a.params.regex)}), a (function () {p.unobtrusive.parse (document)})} (jQuery);regex ", a.params.regex)}), a (function () {p.unobtrusive.parse (document)})} (jQuery);